import math


def GetPCS2CCS(P, Q, Z):
    """
    Преобразует параметрические координаты (P, Q, Z) в декартовы (X, Y, Z).

    Параметры:
    P - длина дуги вдоль внутренней кривой (параметрическая координата)
    Q - проекция точки велосипедиста на внутреннюю кривую (параметрическая координата)
    Z - высота точки велосипедиста над плоскостью пола

    Возвращает:
    (X, Y, Z) - декартовы координаты точки велосипедиста
    """

    # Предположим, что у нас есть функции для получения: Угла наклона трека в точке с параметром P \n
    # Радиуса кривизны внутренней кривой в точке с параметром P
    # Координат центра окружности O1 для точки с параметром P
    # Координат точки L (проекции на внутреннюю кривую) для параметра Q


    theta = get_track_slope_angle(P)
    R = get_inner_curve_radius(Q)
    O1_x, O1_y = get_curve_center(Q)

    L_x, L_y = get_inner_curve_point(Q)

    # Вычисляем расстояние от M2 до L
    # M2 - проекция точки велосипедиста на плоскость пола
    # Это расстояние зависит от угла наклона theta и параметра Q
    LM2_distance = Z * math.tan(theta)
    O1M2_distance = R + LM2_distance

    dx = L_x - O1_x
    dy = L_y - O1_y
    length = math.sqrt(dx * dx + dy * dy)
    if length > 0:
        dx /= length
        dy /= length
    M2_x = O1_x + dx * O1M2_distance
    M2_y = O1_y + dy * O1M2_distance

    X = M2_x
    Y = M2_y

    return (X, Y, Z)


#
def get_track_slope_angle(P):
    """Возвращает угол наклона трека в точке P (в радианах)"""
    return 0.1

#Примеры значений
def get_inner_curve_radius(Q):
    #Возвращает радиус кривизны внутренней кривой в точке Q
    return 10.0


def get_curve_center(Q):
    #Возвращает координаты центра окружности для точки Q на внутренней кривой
    return (0.0, 5.0)


def get_inner_curve_point(Q):
    #Возвращает координаты точки на внутренней кривой для параметра Q
    return (math.sin(Q), math.cos(Q))